""" HTTP-сервер

У Python для роботи з протоколом HTTP можна скористатися пакетом http, який 
реалізує дуже простий HTTP-сервер. Його не варто використовувати для "бойових" 
застосунків, але для навчання та розуміння основних механік роботи вебзастосунку 
його цілком достатньо.

У наступному прикладі ми створили дуже простий HTTP сервер, який приймає запити 
за адресою / та на GET-запит відповідає рядком 'Hello, world!', а на POST-запит 
нічого не робить.

Клієнт створюємо за допомогою класу HTTPConnection та вказуємо хост (адресу) та 
порт сервера. Клієнт робить GET-запит на http://localhost:8001/, викликаючи метод 
getresponse, та виводить у консоль тіло відповіді. Щоб перевірити, що відповідь 
містить тіло, ми можемо перевірити статус-код відповіді (res.status) та причину 
помилки (res.reason), якщо така була.

Щоб запустити сервер в роботу і не блокувати застосунок, запустимо його в окремому 
потоці: """

from threading import Thread
from time import sleep
from http import client
from http.server import HTTPServer, BaseHTTPRequestHandler

class SimpleHTTPRequestHandler(BaseHTTPRequestHandler):
    """ Цей клас визначає, як сервер буде обробляти запити. Ми перевизначаємо методи do_GET
    та do_POST, які відповідають за обробку GET та  POST-запитів відповідно. У методі do_GET 
    ми відправляємо     статус-код 200 (OK), закінчуємо заголовки та записуємо у відповідь 
    рядок 'Hello, world!'. У методі do_POST ми нічого не робимо, тому сервер не відправляє 
    жодної відповіді на POST-запити. Якщо клієнт зробить POST-запит, то він отримає відповідь 
    з кодом 501 (Not Implemented), що означає, що сервер не підтримує цей метод."""

    def do_GET(self):
        """ Метод do_GET викликається, коли сервер отримує GET-запит. У цьому методі ми 
        відправляємо статус-код 200 (OK), закінчуємо заголовки та записуємо у відповідь рядок 
        'Hello, world!'. """
        # Метод send_response відправляє статус-код відповіді, а метод end_headers закінчує
        # заголовки. Метод wfile.write записує байти у відповідь. У цьому випадку ми передаємо
        # рядок'Hello, world!' у вигляді байтів, використовуючи префікс b''. Якщо ми не
        # закінчимо заголовки, то клієнт не зможе правильно обробити відповідь, і може виникнути
        # помилка
        self.send_response(200)
        self.end_headers()
        self.wfile.write(b'Hello, world!')

    def do_POST(self):
        """ Метод do_POST викликається, коли сервер отримує POST-запит. У цьому методі 
        ми нічого не робимо, тому сервер не відправляє жодної відповіді на POST-запити. 
        Якщо клієнт зробить POST-запит, то він отримає відповідь з кодом 501 (Not Implemented), 
        що означає, що сервер не підтримує цей метод. """
        pass

# Створюємо екземпляр HTTPServer, який приймає два аргументи: адресу та порт, на яких сервер
# буде слухати запити, та клас обробника запитів, який визначає, як сервер буде обробляти запити.
# У цьому випадку ми вказуємо адресу 'localhost' та порт 8001,а також клас SimpleHTTPRequestHandler,
# який ми визначили раніше. Після створення сервера ми запускаємо його в окремому потоці, викликаючи
# метод serve_forever,який запускає сервер і дозволяє йому обробляти запити.Ми також використовуємо
# функцію sleep,щоб дати серверу час на запуск, перш ніж клієнт почне робити запити.Якщо ми не
# використаємо sleep, то клієнт може спробувати зробити запит до сервера, який ще не запустився,і
# отримає помилку ConnectionRefusedError. Після того, як клієнт зробить запит і отримає відповідь,
# ми викликаємо метод shutdown сервера,щоб зупинити його роботу. Це дозволяє нам коректно завершити
# роботу сервера та звільнити ресурси,які він використовує. Якщо ми не викличемо shutdown, то сервер
# буде продовжувати працювати, і ми не зможемо завершити застосунок, поки не закриємо його вручну.
# Виклик shutdown зупиняє сервер і дозволяє нам коректно завершити застосунок, звільнивши ресурси,
# які використовує сервер.
httpd = HTTPServer(('localhost', 8001), SimpleHTTPRequestHandler)
server = Thread(target=httpd.serve_forever)
server.start()
sleep(0.5)
# Створюємо клієнт, який буде робити запити до сервера. Ми використовуємо клас HTTPConnection
# з пакету http.client, який дозволяє нам створювати з'єднання з сервером та робити запити.
# Ми вказуємо адресу 'localhost' та порт 8001, які відповідають адресі та порту, на яких працює
# наш сервер.
h1 = client.HTTPConnection('localhost', 8001)
# Після створення клієнта ми викликаємо метод request, щоб зробити GET-запит на адресу '/', що
# відповідає кореневому шляху сервера. Метод request приймає два аргументи: метод запиту (у
# цьому випадку 'GET') та шлях запиту (у цьому випадку '/'). Після того, як ми зробимо запит,
# сервер обробить його та відправить відповідь, яку ми зможемо отримати за допомогою методу
# getresponse клієнта. Метод getresponse повертає об'єкт відповіді, який містить статус-код в
# ідповіді, причину помилки (якщо була) та тіло відповіді. Ми можемо вивести статус-код та причину
# помилки у консоль, а також прочитати тіло відповіді за допомогою методу read, який повертає байти.
# У цьому випадку ми очікуємо отримати рядок 'Hello, world!' у вигляді байтів,тобто b'Hello, world!'
h1.request("GET", "/")

res = h1.getresponse()
print(res.status, res.reason)
data = res.read()
print(data)

httpd.shutdown()

# З неочевидного: ми вказали порт, на якому наш сервер очікує на з'єднання як 8001.
# Якщо порт не вказати, то за замовчуванням буде використаний порт 80, що потребує
# привілеїв адміністратора. У відповіді буде щось на зразок:
# 127.0.0.1 - - [04/Dec/2020 16:51:58] "GET / HTTP/1.1" 200 -
# 200 OK
# b'Hello, world!'
